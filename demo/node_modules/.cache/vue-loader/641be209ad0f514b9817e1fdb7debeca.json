{"remainingRequest":"/Users/zhangzixin/Desktop/USC/DSCI554/project-elements/demo/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/zhangzixin/Desktop/USC/DSCI554/project-elements/demo/src/views/Dashboard.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/zhangzixin/Desktop/USC/DSCI554/project-elements/demo/src/views/Dashboard.vue","mtime":1638508973347},{"path":"/Users/zhangzixin/Desktop/USC/DSCI554/project-elements/demo/node_modules/cache-loader/dist/cjs.js","mtime":1637278779191},{"path":"/Users/zhangzixin/Desktop/USC/DSCI554/project-elements/demo/node_modules/babel-loader/lib/index.js","mtime":1637278778721},{"path":"/Users/zhangzixin/Desktop/USC/DSCI554/project-elements/demo/node_modules/cache-loader/dist/cjs.js","mtime":1637278779191},{"path":"/Users/zhangzixin/Desktop/USC/DSCI554/project-elements/demo/node_modules/vue-loader/lib/index.js","mtime":1637278782397}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCgppbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7CmltcG9ydCB7bmVzdH0gZnJvbSAnZDMtY29sbGVjdGlvbic7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ2QzQ2hhcnQnLAogIGRhdGE6IGZ1bmN0aW9uICgpIHsKICAgIHJldHVybiB7CiAgICAgIHJhd0RhdGE6IG51bGwsCiAgICAgIGxpbmVEYXRhOiBudWxsLAogICAgICByZWdpb246bnVsbCwKICAgICAgdHJlZW1hcERhdGE6bnVsbCwKICAgICAgcGllRGF0YTpudWxsCiAgICB9CiAgfSwKICBtZXRob2RzOiB7CiAgICBjaGFydCgpewoKICAgICAgdmFyIHdpZHRoID0gODAwOwogICAgICB2YXIgaGVpZ2h0ID0gNjAwOwogICAgICB2YXIgbWFyZ2luID0gNTA7CiAgICAgIHZhciB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpCiAgICAgICAgICAgICAgICAuZG9tYWluKFswLDIwMjFdKQogICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pOwoKICAgICAgdmFyIHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKCkKICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIDEwMDBdKQogICAgICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTsKCiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiNsaW5lX2NoYXJ0IikKICAgICAgICAgICAgICAuYXBwZW5kKCJzdmciKQogICAgICAgICAgICAgIC5hdHRyKCJ3aWR0aCIsIHdpZHRoK21hcmdpbikKICAgICAgICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0K21hcmdpbikKICAgICAgICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgYHRyYW5zbGF0ZSgke21hcmdpbn0sICR7bWFyZ2lufSlgKTsKICAgICAgICAgICAgICAKICAgICAgdmFyIHhBeGlzID0gZDMuYXhpc0JvdHRvbSh4U2NhbGUpLnRpY2tzKDUpOwogICAgICB2YXIgeUF4aXMgPSBkMy5heGlzTGVmdCh5U2NhbGUpLnRpY2tzKDUpOwoKICAgICAgc3ZnLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoImNsYXNzIiwgInggYXhpcyIpCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoMCwgJHtoZWlnaHQtbWFyZ2lufSlgKQogICAgICAgIC5jYWxsKHhBeGlzKQogICAgICAgIC50ZXh0KCJZZWFyIik7CiAgICAgICAgCiAgICAgICAgc3ZnLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoImNsYXNzIiwgInkgYXhpcyIpCiAgICAgICAgLmNhbGwoeUF4aXMpCiAgICAgICAgLmFwcGVuZCgndGV4dCcpCiAgICAgICAgLmF0dHIoInkiLCAxNSkKICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgInJvdGF0ZSgtOTApIikKICAgICAgICAuYXR0cigiZmlsbCIsICIjMDAwIikKICAgICAgICAudGV4dCgiTnVtYmVyIG9mIERlbGF5ZWQgRmxpZ2h0cyIpOwogICAgfSwKICAgIGJ1aWxkTGluZUNoYXJ0KCkgewogICAgICAvKnZhciB3aWR0aCA9IDgwMDsKICAgICAgdmFyIGhlaWdodCA9IDgwMDsKICAgICAgdmFyIG1hcmdpbiA9IDUwOwogICAgICB2YXIgZHVyYXRpb24gPSAyNTA7CiAgICAgICovCiAgICAgIHZhciBsaW5lT3BhY2l0eSA9ICIwLjI1IjsKICAgICAgdmFyIGxpbmVPcGFjaXR5SG92ZXIgPSAiMC44NSI7CiAgICAgIHZhciBvdGhlckxpbmVzT3BhY2l0eUhvdmVyID0gIjAuMjUiOwogICAgICB2YXIgbGluZVN0cm9rZSA9ICIycHgiOwogICAgICB2YXIgbGluZVN0cm9rZUhvdmVyID0gIjMuNXB4IjsKICAgICAgLyoKICAgICAgdmFyIGNpcmNsZU9wYWNpdHkgPSAnMC44NSc7CiAgICAgIHZhciBjaXJjbGVPcGFjaXR5T25MaW5lSG92ZXIgPSAiMC4yNSIKICAgICAgdmFyIGNpcmNsZVJhZGl1cyA9IDM7CiAgICAgIHZhciBjaXJjbGVSYWRpdXNIb3ZlciA9IDY7Ki8KCiAgICAgIHZhciBwYXJzZURhdGUgPSBkMy50aW1lUGFyc2UoIiVZLSVtLSVkIik7CgogICAgICB2YXIgZGF0YSA9IHRoaXMubGluZURhdGE7CiAgICAgIC8vY29uc29sZS5sb2coZGF0YVswXS5GTF9EQVRFKTsgLy90aGlzIHdvcmtzCgogICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkgeyAKICAgICAgICBkLmRhdGUgPSBwYXJzZURhdGUoZC5GTF9EQVRFKTsKICAgICAgICBkLmNhcnJpZXIgPSBkLk1LVF9VTklRVUVfQ0FSUklFUjsKICAgICAgICBkLmRlbGF5ID0gK2QuTlVNX09GX0RFTEFZOyAgCgogICAgICB9KTsKCiAgICAgIAogICAgICB2YXIgc3Vtc3RhdCA9IG5lc3QoKSAvLyBuZXN0IGZ1bmN0aW9uIGFsbG93cyB0byBncm91cCB0aGUgY2FsY3VsYXRpb24gcGVyIGxldmVsIG9mIGEgZmFjdG9yCiAgICAgICAgICAua2V5KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuY2Fycmllcjt9KQogICAgICAgICAgLmVudHJpZXMoZGF0YSk7CgogICAgICAvL2NvbnNvbGUubG9nKHN1bXN0YXQpOyAvL3dvcmtpbmcKCiAgICAgIHZhciBhcnJfdGltZSA9IGQzLmV4dGVudChkYXRhLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmRhdGU7IH0pCiAgICAgIAogICAgICB2YXIgbWFyZ2luID0ge3RvcDogMTAsIHJpZ2h0OiAzMCwgYm90dG9tOiAzMCwgbGVmdDogNjB9LAogICAgICAgICAgd2lkdGggPSAxMjAwIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsCiAgICAgICAgICBoZWlnaHQgPSA2MDAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsKCiAgICAgIC8vIGFwcGVuZCB0aGUgc3ZnIG9iamVjdCB0byB0aGUgYm9keSBvZiB0aGUgcGFnZQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjbGluZV9jaGFydCIpCiAgICAgICAgLmFwcGVuZCgic3ZnIikKICAgICAgICAgIC5hdHRyKCJ3aWR0aCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpCiAgICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pCiAgICAgICAgLmFwcGVuZCgiZyIpCiAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwKICAgICAgICAgICAgICAgICJ0cmFuc2xhdGUoIiArIG1hcmdpbi5sZWZ0ICsgIiwiICsgbWFyZ2luLnRvcCArICIpIik7CgogICAgICAvL2NvbnNvbGUubG9nKGFycl90aW1lKTsgLy93b3JraW5nCiAgICAgIC8vQWRkIHgtYXhpcwogICAgICB2YXIgeCA9IGQzLnNjYWxlTGluZWFyKCkKICAgICAgICAuZG9tYWluKGFycl90aW1lKQogICAgICAgIC5yYW5nZShbIDAsIHdpZHRoIF0pOwogICAgICBzdmcuYXBwZW5kKCJnIikKICAgICAgICAudHJhbnNpdGlvbigpCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoMCwiICsgaGVpZ2h0ICsgIikiKQogICAgICAgIC5jYWxsKGQzLmF4aXNCb3R0b20oeCkudGlja3MoMzIpLnRpY2tGb3JtYXQoZDMudGltZUZvcm1hdCgnJWIgJWQnKSkpOwoKICAgICAgdmFyIG1heF9kYXRhID0gZDMubWF4KGRhdGEsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICtkLmRlbGF5OyB9KQogICAgICAvL2NvbnNvbGUubG9nKG1heF9kYXRhKQoKICAgICAgLy8gQWRkIHktYXhpcwogICAgICB2YXIgeSA9IGQzLnNjYWxlTGluZWFyKCkKICAgICAgICAuZG9tYWluKFswLCBtYXhfZGF0YV0pCiAgICAgICAgLnJhbmdlKFsgaGVpZ2h0LCAwIF0pOwogICAgICBzdmcuYXBwZW5kKCJnIikKICAgICAgICAuY2FsbChkMy5heGlzTGVmdCh5KSkKICAgICAgICAuYXBwZW5kKCd0ZXh0JykKICAgICAgICAuYXR0cigieCIsIC0xNTApCiAgICAgICAgLmF0dHIoInkiLCAtNDApCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsICJyb3RhdGUoLTkwKSIpCiAgICAgICAgLmF0dHIoImZpbGwiLCAiIzY5Njk2OSIpCiAgICAgICAgLmF0dHIoImZvbnQtc2l6ZSIsICIxNHB4IikKICAgICAgICAudGV4dCgiTnVtYmVyIG9mIERlbGF5ZWQgRmxpZ2h0cyIpOwoKICAgICAgdmFyIGNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKGQzLnNjaGVtZUNhdGVnb3J5MTApOwoKICAgICAgLyoKICAgICAgY29uc3QgdHJhbnNpdGlvblBhdGggPSBkMwogICAgICAgIC50cmFuc2l0aW9uKCkKICAgICAgICAuZWFzZShkMy5lYXNlU2luKQogICAgICAgIC5kdXJhdGlvbigxMDAwKTsqLwogICAgICAvL2NvbnNvbGUubG9nKHRyYW5zaXRpb25QYXRoKQoKICAgICAgc3ZnLnNlbGVjdEFsbCgiLmxpbmUiKQogICAgICAuZGF0YShzdW1zdGF0KQogICAgICAuZW50ZXIoKQogICAgICAuYXBwZW5kKCJwYXRoIikKICAgICAgICAuYXR0cigiZmlsbCIsICJub25lIikKICAgICAgICAuYXR0cigic3Ryb2tlIiwgZnVuY3Rpb24oZCl7IHJldHVybiBjb2xvcihkLmtleSkgfSkKICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgbGluZVN0cm9rZSkKICAgICAgICAuYXR0cigib3BhY2l0eSIsIGxpbmVPcGFjaXR5KQogICAgICAgIC5hdHRyKCJkIiwgZnVuY3Rpb24oZCl7CiAgICAgICAgICByZXR1cm4gZDMubGluZSgpCiAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHgoZC5kYXRlKTsgfSkKICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCkgeyByZXR1cm4geSgrZC5kZWxheSk7IH0pKGQudmFsdWVzKQogICAgICAgIH0pCiAgICAgICAgLm9uKCJtb3VzZW92ZXIiLCBmdW5jdGlvbihkLGkpIHsKICAgICAgICAgIC8vY29uc29sZS5sb2coaSkKICAgICAgICAgICAgc3ZnLmFwcGVuZCgidGV4dCIpCiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKQogICAgICAgICAgICAgIC5lYXNlKGQzLmVhc2VTaW4pCiAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgInRpdGxlLXRleHQiKQogICAgICAgICAgICAgIC5zdHlsZSgiZmlsbCIsIGNvbG9yKGkua2V5KSkgIAogICAgICAgICAgICAgIC5zdHlsZSgiZm9udC1zaXplIiwgIjIycHgiKSAgICAgIAogICAgICAgICAgICAgIC50ZXh0KCJDYXJyaWVyOiAiK2kua2V5KQogICAgICAgICAgICAgIC5hdHRyKCJ0ZXh0LWFuY2hvciIsICJtaWRkbGUiKQogICAgICAgICAgICAgIC5hdHRyKCJ4IiwgMTAwKQogICAgICAgICAgICAgIC5hdHRyKCJ5IiwgMjApOwogICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5saW5lJykKICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5Jywgb3RoZXJMaW5lc09wYWNpdHlIb3Zlcik7CiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKQogICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGxpbmVPcGFjaXR5SG92ZXIpCiAgICAgICAgICAgICAgLnN0eWxlKCJzdHJva2Utd2lkdGgiLCBsaW5lU3Ryb2tlSG92ZXIpCiAgICAgICAgICAgICAgLnN0eWxlKCJjdXJzb3IiLCAicG9pbnRlciIpOwogICAgICAgICAgfSkKICAgICAgICAub24oIm1vdXNlb3V0IiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHN2Zy5zZWxlY3QoIi50aXRsZS10ZXh0IikucmVtb3ZlKCk7CiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmxpbmUiKQogICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgbGluZU9wYWNpdHkpOwogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykKICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBsaW5lT3BhY2l0eSkKICAgICAgICAgICAgICAuc3R5bGUoInN0cm9rZS13aWR0aCIsIGxpbmVTdHJva2UpCiAgICAgICAgICAgICAgLnN0eWxlKCJjdXJzb3IiLCAibm9uZSIpOwogICAgICAgICAgfSkKICAgICAgICAgIDsKCiAgICAgICAgCiAgICAgIAogICAgICAgIHZhciBjdXJ0YWluID0gc3ZnLmFwcGVuZCgncmVjdCcpCiAgICAgICAgICAuYXR0cigneCcsIC0xICogd2lkdGgpCiAgICAgICAgICAuYXR0cigneScsIC0xICogaGVpZ2h0KQogICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCkKICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKQogICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2N1cnRhaW4nKQogICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICdyb3RhdGUoMTgwKScpCiAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnI2ZmZmZmZicpOwogICAgICAgICAgCiAgICAgICAgLyogT3B0aW9uYWxseSBhZGQgYSBndWlkZWxpbmUgKi8KICAgICAgICB2YXIgZ3VpZGVsaW5lID0gc3ZnLmFwcGVuZCgnbGluZScpCiAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyMzMzMnKQogICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDApCiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZ3VpZGUnKQogICAgICAgICAgLmF0dHIoJ3gxJywgMSkKICAgICAgICAgIC5hdHRyKCd5MScsIDEpCiAgICAgICAgICAuYXR0cigneDInLCAxKQogICAgICAgICAgLmF0dHIoJ3kyJywgaGVpZ2h0KQogICAgICAgICAgCiAgICAgICAgLyogQ3JlYXRlIGEgc2hhcmVkIHRyYW5zaXRpb24gZm9yIGFueXRoaW5nIHdlJ3JlIGFuaW1hdGluZyAqLwogICAgICAgIHZhciB0ID0gc3ZnLnRyYW5zaXRpb24oKQogICAgICAgICAgLmRlbGF5KDc1MCkKICAgICAgICAgIC5kdXJhdGlvbig2MDAwKQogICAgICAgICAgLmVhc2UoZDMuZWFzZUxpbmVhcikKICAgICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGQzLnNlbGVjdCgnbGluZS5ndWlkZScpCiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKQogICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApCiAgICAgICAgICAgICAgLnJlbW92ZSgpCiAgICAgICAgICB9KTsKICAgICAgICAKICAgICAgICB0LnNlbGVjdCgncmVjdC5jdXJ0YWluJykKICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDApOwogICAgICAgIHQuc2VsZWN0KCdsaW5lLmd1aWRlJykKICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB3aWR0aCArICcsIDApJykKCiAgICAgICAgZDMuc2VsZWN0KCIjc2hvd19ndWlkZWxpbmUiKS5vbigiY2hhbmdlIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICBndWlkZWxpbmUuYXR0cignc3Ryb2tlLXdpZHRoJywgdGhpcy5jaGVja2VkID8gMSA6IDApOwogICAgICAgICAgY3VydGFpbi5hdHRyKCJvcGFjaXR5IiwgdGhpcy5jaGVja2VkID8gMC43NSA6IDEpOwogICAgICAgIH0pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9LAogICAgYnVpbGRUcmVlbWFwKCkgewogICAgICB2YXIgd2lkdGggPSA5NTQ7CiAgICAgIHZhciBoZWlnaHQgPSA5NTQ7CgogICAgICBjb25zdCBrZXlzID0gZDMucmFuZ2UoMSwgMzIpOwogICAgICAvL2NvbnNvbGUubG9nKGtleXMpCiAgICAgIC8vY29uc29sZS5sb2codGhpcy50cmVlbWFwRGF0YSkKCiAgICAgIHZhciBkYXRhID0gdGhpcy50cmVlbWFwRGF0YTsKCiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IAogICAgICAgIGQubmFtZSA9IGQuT1JJR0lOX1NUQVRFX05NCiAgICAgICAgZC52YWx1ZXMgPSAga2V5cy5tYXAoa2V5ID0+ICtkW2tleV0ucmVwbGFjZSgvLC9nLCAiIikpCiAgICAgIH0pOwogICAgICAvL2NvbnNvbGUubG9nKGRhdGEpCiAgICAgIAogICAgICBjb25zdCByZWdpb25CeVN0YXRlID0gbmV3IE1hcCh0aGlzLnJlZ2lvbi5tYXAoZCA9PiBbZC5TdGF0ZSwgZC5SZWdpb25dKSk7CiAgICAgIC8vY29uc29sZS5sb2cocmVnaW9uQnlTdGF0ZSkKICAgICAgY29uc3QgZGl2aXNpb25CeVN0YXRlID0gbmV3IE1hcCh0aGlzLnJlZ2lvbi5tYXAoZCA9PiBbZC5TdGF0ZSwgZC5EaXZpc2lvbl0pKTsKICAgICAgLy9jb25zb2xlLmxvZyhkaXZpc2lvbkJ5U3RhdGUpCgogICAgICBjb25zdCBncm91cCA9IGQzLmdyb3VwKGRhdGEsIGQgPT4gcmVnaW9uQnlTdGF0ZS5nZXQoZC5PUklHSU5fU1RBVEVfTk0pLCBkID0+IGRpdmlzaW9uQnlTdGF0ZS5nZXQoZC5PUklHSU5fU1RBVEVfTk0pKQogICAgICAvL2NvbnNvbGUubG9nKGdyb3VwKQoKICAgICAgdmFyIGNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKGdyb3VwLmtleXMoKSwgZDMuc2NoZW1lQ2F0ZWdvcnkxMC5tYXAoZCA9PiBkMy5pbnRlcnBvbGF0ZVJnYihkLCAid2hpdGUiKSgwLjUpKSkKICAgICAgLy9jb25zb2xlLmxvZyhjb2xvcikKCiAgICAgIHZhciBzdW1zID0ga2V5cy5tYXAoKGQsIGkpID0+IGQzLmhpZXJhcmNoeShncm91cCkuc3VtKGQgPT4gZC52YWx1ZXNbaV0pLnZhbHVlKTsKICAgICAgLy9jb25zb2xlLmxvZyhzdW1zKQoKICAgICAgdmFyIG1heCA9IGQzLm1heChzdW1zKTsKICAgICAgLy9jb25zb2xlLmxvZyhtYXgpCgogICAgICBjb25zdCB0cmVlbWFwID0gZDMudHJlZW1hcCgpCiAgICAgIC50aWxlKGQzLnRyZWVtYXBSZXNxdWFyaWZ5KQogICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pCiAgICAgIC5wYWRkaW5nKGQgPT4gZC5oZWlnaHQgPT09IDEgPyAxIDogMCkKICAgICAgLnJvdW5kKHRydWUpOwoKICAgICAgLy9jb25zb2xlLmxvZyh0cmVlbWFwKQoKICAgICAgY29uc3Qgcm9vdCA9IHRyZWVtYXAoZDMuaGllcmFyY2h5KGdyb3VwKQogICAgICAgIC5zdW0oZCA9PiBBcnJheS5pc0FycmF5KGQudmFsdWVzKSA/IGQzLnN1bShkLnZhbHVlcykgOiAwKQogICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnZhbHVlIC0gYS52YWx1ZSkpOwogICAgICAvL2NvbnNvbGUubG9nKHJvb3QpCiAgICAKCiAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjdHJlZW1hcCIpCiAgICAgICAgLmFwcGVuZCgic3ZnIikKICAgICAgICAuYXR0cigiZm9udC1mYW1pbHkiLCAic2Fucy1zZXJpZiIpCiAgICAgICAgLmF0dHIoImZvbnQtc2l6ZSIsIDEwKQogICAgICAgIC5zdHlsZSgib3ZlcmZsb3ciLCAidmlzaWJsZSIpOwoKICAgIHZhciBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoIixkIik7CiAgICB2YXIgZHVyYXRpb24gPSAyNTAwOwogICAgdmFyIHBhcnNlTnVtYmVyID0gc3RyaW5nID0+ICtzdHJpbmcucmVwbGFjZSgvLC9nLCAiIik7CgogICAgdmFyIGJveCA9IHN2Zy5hcHBlbmQoImciKQogICAgLnNlbGVjdEFsbCgiZyIpCiAgICAuZGF0YShrZXlzLm1hcCgoa2V5LCBpKSA9PiB7CiAgICAgIGNvbnN0IHZhbHVlID0gcm9vdC5zdW0oZCA9PiBkLnZhbHVlc1tpXSkudmFsdWU7CiAgICAgIHJldHVybiB7a2V5LCB2YWx1ZSwgaSwgazogTWF0aC5zcXJ0KHZhbHVlIC8gbWF4KX07CiAgICB9KS5yZXZlcnNlKCkpCiAgICAuam9pbigiZyIpCiAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAoe2t9KSA9PiBgdHJhbnNsYXRlKCR7KDEgLSBrKSAvIDIgKiB3aWR0aH0sJHsoMSAtIGspIC8gMiAqIGhlaWdodH0pYCkKICAgICAgLmNhbGwoZyA9PiBnLmFwcGVuZCgidGV4dCIpCiAgICAgICAgICAuYXR0cigieSIsIC02KQogICAgICAgICAgLmF0dHIoImZpbGwiLCAiIzc3NyIpCiAgICAgICAgLnNlbGVjdEFsbCgidHNwYW4iKQogICAgICAgIC5kYXRhKCh7a2V5LCB2YWx1ZX0pID0+IFtrZXksIGAgJHtmb3JtYXROdW1iZXIodmFsdWUpfWBdKQogICAgICAgIC5qb2luKCJ0c3BhbiIpCiAgICAgICAgICAuYXR0cigiZm9udC13ZWlnaHQiLCAoZCwgaSkgPT4gaSA9PT0gMCA/ICJib2xkIiA6IG51bGwpCiAgICAgICAgICAudGV4dChkID0+IGQpKQogICAgICAuY2FsbChnID0+IGcuYXBwZW5kKCJyZWN0IikKICAgICAgICAgIC5hdHRyKCJmaWxsIiwgIm5vbmUiKQogICAgICAgICAgLmF0dHIoInN0cm9rZSIsICIjY2NjIikKICAgICAgICAgIC5hdHRyKCJ3aWR0aCIsICh7a30pID0+IGsgKiB3aWR0aCApCiAgICAgICAgICAuYXR0cigiaGVpZ2h0IiwgKHtrfSkgPT4gayAqIGhlaWdodCkpOwogICAgICAKICAgICAgLy9jb25zb2xlLmxvZyhib3gpCgogICAgICAgY29uc3QgbGVhZiA9IHN2Zy5hcHBlbmQoImciKQogICAgICAgICAgLnNlbGVjdEFsbCgiZyIpCiAgICAgICAgICAuZGF0YShsYXlvdXQoa2V5cykpCiAgICAgICAgICAuam9pbigiZyIpCiAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBkID0+IGB0cmFuc2xhdGUoJHtkLngwfSwke2QueTB9KWApOwogICAgICAgIC8vY29uc29sZS5sb2cobGVhZikKICAgICAgICAKICAgICAgICBsZWFmLmFwcGVuZCgicmVjdCIpCiAgICAgICAgICAgIC8vLmF0dHIoImlkIiwgZCA9PiAoZC5sZWFmVWlkID0gRE9NLnVpZCgibGVhZiIpKS5pZCkKICAgICAgICAgICAgLmF0dHIoImZpbGwiLCBkID0+IHsgd2hpbGUgKGQuZGVwdGggPiAxKSBkID0gZC5wYXJlbnQ7IHJldHVybiBjb2xvcihrZXlzKTsgfSkKICAgICAgICAgICAgLmF0dHIoIndpZHRoIiwgZCA9PiBkLngxIC0gZC54MCkKICAgICAgICAgICAgLmF0dHIoImhlaWdodCIsIGQgPT4gZC55MSAtIGQueTApOwogICAgICAgIC8qCiAgICAgICAgbGVhZi5hcHBlbmQoImNsaXBQYXRoIikKICAgICAgICAgICAgLmF0dHIoImlkIiwgZCA9PiAoZC5jbGlwVWlkID0gRE9NLnVpZCgiY2xpcCIpKS5pZCkKICAgICAgICAgIC5hcHBlbmQoInVzZSIpCiAgICAgICAgICAgIC5hdHRyKCJ4bGluazpocmVmIiwgZCA9PiBkLmxlYWZVaWQuaHJlZik7CiAgICAgICAgKi8KICAgICAgICBsZWFmLmFwcGVuZCgidGV4dCIpCiAgICAgICAgICAgIC5hdHRyKCJjbGlwLXBhdGgiLCBkID0+IGQuY2xpcFVpZCkKICAgICAgICAgIC5zZWxlY3RBbGwoInRzcGFuIikKICAgICAgICAgIC5kYXRhKFtncm91cC5uYW1lLCBmb3JtYXROdW1iZXIoZ3JvdXAudmFsdWUpXSkKICAgICAgICAgIC5qb2luKCJ0c3BhbiIpCiAgICAgICAgICAgIC5hdHRyKCJ4IiwgMykKICAgICAgICAgICAgLmF0dHIoInkiLCAoZCwgaSwgbm9kZXMpID0+IGAkeyhpID09PSBub2Rlcy5sZW5ndGggLSAxKSAqIDAuMyArIDEuMSArIGkgKiAwLjl9ZW1gKQogICAgICAgICAgICAuYXR0cigiZmlsbC1vcGFjaXR5IiwgKGQsIGksIG5vZGVzKSA9PiBpID09PSBub2Rlcy5sZW5ndGggLSAxID8gMC43IDogbnVsbCkKICAgICAgICAgICAgLnRleHQoZCA9PiBkKTsKCiAgICAgICAgbGVhZi5hcHBlbmQoInRpdGxlIikKICAgICAgICAgICAgLnRleHQoZ3JvdXAubmFtZSk7CgogICAgICAgIGZ1bmN0aW9uIGxheW91dChpbmRleCkgewogICAgICAgICAgY29uc3QgayA9IE1hdGguc3FydChyb290LnN1bShkID0+IGQudmFsdWVzW2luZGV4XSkudmFsdWUgLyBtYXgpOwogICAgICAgICAgY29uc3QgeCA9ICgxIC0gaykgLyAyICogd2lkdGg7CiAgICAgICAgICBjb25zdCB5ID0gKDEgLSBrKSAvIDIgKiBoZWlnaHQ7CiAgICAgICAgICByZXR1cm4gdHJlZW1hcC5zaXplKFt3aWR0aCAqIGssIGhlaWdodCAqIGtdKShyb290KQogICAgICAgICAgICAuZWFjaChkID0+IChkLngwICs9IHgsIGQueDEgKz0geCwgZC55MCArPSB5LCBkLnkxICs9IHkpKQogICAgICAgICAgICAubGVhdmVzKCk7CiAgICAgICAgfQoKICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdmcubm9kZSgpLCB7CiAgICB1cGRhdGUoaW5kZXgpIHsKICAgICAgYm94LnRyYW5zaXRpb24oKQogICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKQogICAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAoe2l9KSA9PiBpID49IGluZGV4ID8gMSA6IDApOwoKICAgICAgbGVhZi5kYXRhKGxheW91dChpbmRleCkpLnRyYW5zaXRpb24oKQogICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKQogICAgICAgICAgLmVhc2UoZDMuZWFzZUxpbmVhcikKICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBkID0+IGB0cmFuc2xhdGUoJHtkLngwfSwke2QueTB9KWApCiAgICAgICAgICAuY2FsbChsZWFmID0+IGxlYWYuc2VsZWN0KCJyZWN0IikKICAgICAgICAgICAgICAuYXR0cigid2lkdGgiLCBkID0+IGQueDEgLSBkLngwKQogICAgICAgICAgICAgIC5hdHRyKCJoZWlnaHQiLCBkID0+IGQueTEgLSBkLnkwKSkKICAgICAgICAgIC5jYWxsKGxlYWYgPT4gbGVhZi5zZWxlY3QoInRleHQgdHNwYW46bGFzdC1jaGlsZCIpCiAgICAgICAgICAgICAgLnR3ZWVuKCJ0ZXh0IiwgZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgICAgY29uc3QgaSA9IGQzLmludGVycG9sYXRlKHBhcnNlTnVtYmVyKHRoaXMudGV4dENvbnRlbnQpLCBkLnZhbHVlKTsKICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7IHRoaXMudGV4dENvbnRlbnQgPSBmb3JtYXROdW1iZXIoaSh0KSk7IH07CiAgICAgICAgICAgICAgfSkpOwogICAgfQogIH0pOwoKICAgIH0sCiAgICBidWlsZFBpZUNoYXJ0KCl7CgogICAgICAgIHZhciB3aWR0aCA9IDYwMDsKICAgICAgICB2YXIgaGVpZ2h0ID0gNjAwOwogICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7CiAgICAgICAgdmFyIGRvbnV0V2lkdGggPSAxMjA7CiAgICAgICAgdmFyIGxlZ2VuZFJlY3RTaXplID0gMTU7CiAgICAgICAgdmFyIGxlZ2VuZFNwYWNpbmcgPSA1OwoKICAgICAgICB2YXIgY29sb3IgPSBkMy5zY2FsZU9yZGluYWwoZDMuc2NoZW1lQ2F0ZWdvcnkxMCk7CgogICAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5waWVEYXRhOwogICAgICAgIAogICAgICAgIGRhdGFzZXQuZm9yRWFjaChmdW5jdGlvbihkKSB7CiAgICAgICAgICAgIGQuY291bnQgPSArZC5jb3VudDsKICAgICAgICAgIH0pOwoKICAgICAgICBjb25zb2xlLmxvZyhkYXRhc2V0KTsKCiAgICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgnI3BpZV9jaGFydCcpCiAgICAgICAgICAuYXBwZW5kKCdzdmcnKQogICAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpCiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KQogICAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHdpZHRoIC8gMikgKyAKICAgICAgICAgICAgJywnICsgKGhlaWdodCAvIDIpICsgJyknKTsKCiAgICAgICAgdmFyIGFyYyA9IGQzLmFyYygpCiAgICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzIC0gZG9udXRXaWR0aCkKICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMpOwoKICAgICAgICB2YXIgcGllID0gZDMucGllKCkKICAgICAgICAgIC52YWx1ZShmdW5jdGlvbihkKSB7IHJldHVybiBkLmNvdW50OyB9KQogICAgICAgICAgLnNvcnQobnVsbCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgIHZhciBwYXRoID0gc3ZnLnNlbGVjdEFsbCgncGF0aCcpCiAgICAgICAgICAgIC5kYXRhKHBpZShkYXRhc2V0KSkKICAgICAgICAgICAgLmVudGVyKCkKICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpCiAgICAgICAgICAgIC5hdHRyKCdkJywgYXJjKQogICAgICAgICAgICAuYXR0cignZmlsbCcsIGZ1bmN0aW9uKGQpIHsgCiAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGQuZGF0YS5sYWJlbCk7CiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgdG90YWwgPSBkMy5zdW0oZGF0YXNldC5tYXAoZnVuY3Rpb24oZCkgeyAgCiAgICAgICAgICAgICAgcmV0dXJuIGQuY291bnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICB9KSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcGVyY2VudCA9IE1hdGgucm91bmQoMTAwMCAqIGkuZGF0YS5jb3VudCAvIHRvdGFsKSAvIDEwOyAKCiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKQogICAgICAgICAgICAuYXR0cigic3Ryb2tlIiwgIiMwMDAiKQoKICAgICAgICAgICAgc3ZnLmFwcGVuZCgidGV4dCIpCiAgICAgICAgICAgIC5hdHRyKCJ5IiwgMTAwKQogICAgICAgICAgICAuc3R5bGUoInRleHQtYW5jaG9yIiwgIm1pZGRsZSIpCiAgICAgICAgICAgIC5zdHlsZSgiZm9udC1zaXplIiwgMjQpCiAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsImxhYmVsIikKICAgICAgICAgICAgLnN0eWxlKCJmaWxsIiwgY29sb3IoaS5kYXRhLmxhYmVsKSkKICAgICAgICAgICAgLnRleHQoIlBlcmNlbnRhZ2U6IiArIHBlcmNlbnQgKyAiJSIpOwoKICAgICAgICAgICAgc3ZnLmFwcGVuZCgidGV4dCIpCiAgICAgICAgICAgIC5hdHRyKCJ5IiwgLTkwKQogICAgICAgICAgICAuc3R5bGUoInRleHQtYW5jaG9yIiwgIm1pZGRsZSIpCiAgICAgICAgICAgIC5zdHlsZSgiZm9udC1zaXplIiwgMjQpCiAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsImxhYmVsMiIpCiAgICAgICAgICAgIC5zdHlsZSgiZmlsbCIsIGNvbG9yKGkuZGF0YS5sYWJlbCkpCiAgICAgICAgICAgIC50ZXh0KGkuZGF0YS5sYWJlbCk7CgogICAgICAgICAgfSk7ICAgICAgICAgICAgICAgCiAgICAgICAgICAKICAgICAgICAgIHBhdGgub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInN0cm9rZSIsIG51bGwpOyAgCiAgICAgICAgICAgIHN2Zy5zZWxlY3QoIi5sYWJlbCIpLnJlbW92ZSgpOwogICAgICAgICAgICBzdmcuc2VsZWN0KCIubGFiZWwyIikucmVtb3ZlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAvKgogICAgICAgICAgcGF0aC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZCkgeyAgCiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ3RvcCcsIChkLnBhZ2VZICsgMTApICsgJ3B4JykgICAgICAgICAgCiAgICAgICAgICAgICAgLnN0eWxlKCdsZWZ0JywgKGQzLnBhZ2VYICsgMTApICsgJ3B4Jyk7ICAgICAgICAgICAgIAogICAgICAgICAgfSk7ICAgICAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAKICAgICAgICAgIHZhciBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKCcubGVnZW5kJykKICAgICAgICAgICAgLmRhdGEoY29sb3IuZG9tYWluKCkpCiAgICAgICAgICAgIC5lbnRlcigpCiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kJykKICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHsKICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gbGVnZW5kUmVjdFNpemUgKyBsZWdlbmRTcGFjaW5nOwogICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAgaGVpZ2h0ICogY29sb3IuZG9tYWluKCkubGVuZ3RoIC8gMjsKICAgICAgICAgICAgICB2YXIgaG9yeiA9IC02ICogbGVnZW5kUmVjdFNpemU7CiAgICAgICAgICAgICAgdmFyIHZlcnQgPSBpICogaGVpZ2h0IC0gb2Zmc2V0OwogICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBob3J6ICsgJywnICsgdmVydCArICcpJzsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgbGVnZW5kLmFwcGVuZCgncmVjdCcpCiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGxlZ2VuZFJlY3RTaXplKQogICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgbGVnZW5kUmVjdFNpemUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY29sb3IpCiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgY29sb3IpOwogICAgICAgICAgICAKICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3RleHQnKQogICAgICAgICAgICAuYXR0cigneCcsIGxlZ2VuZFJlY3RTaXplICsgbGVnZW5kU3BhY2luZykKICAgICAgICAgICAgLmF0dHIoJ3knLCBsZWdlbmRSZWN0U2l6ZSAtIGxlZ2VuZFNwYWNpbmcpCiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pOwogICAgfQoKICB9LAogIG1vdW50ZWQ6IGZ1bmN0aW9uICgpIHsKCiAgICBpZiAoIXRoaXMuJHN0b3JlLnN0YXRlLmh0bWxNYXBEYXRhKSB7CiAgICAgIHZhciBwcm9taXNlcyA9IFtdCiAgICAgIHByb21pc2VzLnB1c2goZDMuY3N2KCdEYXRhX2Zvcl9saW5lX2NoYXJ0LmNzdicpKQogICAgICBwcm9taXNlcy5wdXNoKGQzLmNzdigndXMtcmVnaW9uLmNzdicpKQogICAgICBwcm9taXNlcy5wdXNoKGQzLmNzdignRGF0YV9mb3JfdHJlZW1hcC5jc3YnKSkKICAgICAgcHJvbWlzZXMucHVzaChkMy5jc3YoJ2RlbGF5LmNzdicpKQogICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbih2YWx1ZXMgPT4gewogICAgICAgIHRoaXMucmF3RGF0YSA9IHZhbHVlcwogICAgICAgIHRoaXMubGluZURhdGEgPSB2YWx1ZXNbMF0KICAgICAgICB0aGlzLnJlZ2lvbiA9IHZhbHVlc1sxXQogICAgICAgIHRoaXMudHJlZW1hcERhdGEgPSB2YWx1ZXNbMl0KICAgICAgICB0aGlzLnBpZURhdGEgPSB2YWx1ZXNbM10KICAgICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ2h0bWxNYXBEYXRhJywgdGhpcy5yYXdEYXRhKTsKICAgICAgICAvL3RoaXMuY2hhcnQoKTsKICAgICAgICB0aGlzLmJ1aWxkTGluZUNoYXJ0KCk7CiAgICAgICAgLy90aGlzLmJ1aWxkVHJlZW1hcCgpOwogICAgICAgIHRoaXMuYnVpbGRQaWVDaGFydCgpOwogICAgICB9KQogICAgfSBlbHNlIHsKICAgICAgdGhpcy5yYXdEYXRhID0gdGhpcy4kc3RvcmUuc3RhdGUuaHRtbE1hcERhdGE7CiAgICAgIHRoaXMubGluZURhdGEgPSB0aGlzLnJhd0RhdGFbMF0KICAgICAgdGhpcy5yZWdpb24gPSB0aGlzLnJhd0RhdGFbMV0KICAgICAgdGhpcy50cmVlbWFwRGF0YSA9IHRoaXMucmF3RGF0YVsyXQogICAgICB0aGlzLmNoYXJ0KCk7CiAgICAgIHRoaXMuYnVpbGRMaW5lQ2hhcnQoKTsKICAgICAgLy90aGlzLmJ1aWxkVHJlZW1hcCgpOwogICAgICB0aGlzLmJ1aWxkUGllQ2hhcnQoKTsKICAgIH0KCiAgICB9CiAgfQoK"},{"version":3,"sources":["Dashboard.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA","file":"Dashboard.vue","sourceRoot":"src/views","sourcesContent":["<template>\n    <div class=\"about\">\n    <b-tabs content-class=\"mt-3\">\n        <b-tab title=\"Carrier Analysis\" active>\n            <h1>Interactive & Animated Line Chart</h1>\n            <div class=\"title\"> Number Of Delayed Flight Count For Carriers Through Time</div>\n            <br />\n            <label class=\"guideline\">\n              Show Guideline & Curtain\n              <input type=\"checkbox\" id=\"show_guideline\" />\n            </label>\n            <br />\n            <svg width=\"1200\" height=\"600\" id=\"line_chart\"></svg>\n        </b-tab>\n\n        <b-tab title=\"States Analysis\">\n            <h1>D3 Animated Treemap</h1>\n            <div class=\"title\"> Number Of Delayed Flight Count For Carriers Through Time</div>\n            <svg width=\"954\" height=\"954\" id=\"treemap\"></svg>\n        </b-tab>\n\n        <b-tab title=\"Reasons Analysis\">\n            <h1>What are the reasons a flight gets delayed?</h1>\n            <div class=\"title\"> Percentage of Each Delayed Reasons Shown in Donut Chart</div>\n            <br/>\n            <svg width=\"600\" height=\"600\" id=\"pie_chart\"></svg>\n        </b-tab>\n    </b-tabs>\n  </div>\n</template>\n\n<script>\n\nimport * as d3 from 'd3';\nimport {nest} from 'd3-collection';\n\nexport default {\n  name: 'd3Chart',\n  data: function () {\n    return {\n      rawData: null,\n      lineData: null,\n      region:null,\n      treemapData:null,\n      pieData:null\n    }\n  },\n  methods: {\n    chart(){\n\n      var width = 800;\n      var height = 600;\n      var margin = 50;\n      var xScale = d3.scaleLinear()\n                .domain([0,2021])\n                .range([0, width]);\n\n      var yScale = d3.scaleLinear()\n                .domain([0, 1000])\n                .range([height, 0]);\n\n      var svg = d3.select(\"#line_chart\")\n              .append(\"svg\")\n              .attr(\"width\", width+margin)\n              .attr(\"height\", height+margin)\n              .append('g')\n              .attr(\"transform\", `translate(${margin}, ${margin})`);\n              \n      var xAxis = d3.axisBottom(xScale).ticks(5);\n      var yAxis = d3.axisLeft(yScale).ticks(5);\n\n      svg.append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", `translate(0, ${height-margin})`)\n        .call(xAxis)\n        .text(\"Year\");\n        \n        svg.append(\"g\")\n        .attr(\"class\", \"y axis\")\n        .call(yAxis)\n        .append('text')\n        .attr(\"y\", 15)\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"fill\", \"#000\")\n        .text(\"Number of Delayed Flights\");\n    },\n    buildLineChart() {\n      /*var width = 800;\n      var height = 800;\n      var margin = 50;\n      var duration = 250;\n      */\n      var lineOpacity = \"0.25\";\n      var lineOpacityHover = \"0.85\";\n      var otherLinesOpacityHover = \"0.25\";\n      var lineStroke = \"2px\";\n      var lineStrokeHover = \"3.5px\";\n      /*\n      var circleOpacity = '0.85';\n      var circleOpacityOnLineHover = \"0.25\"\n      var circleRadius = 3;\n      var circleRadiusHover = 6;*/\n\n      var parseDate = d3.timeParse(\"%Y-%m-%d\");\n\n      var data = this.lineData;\n      //console.log(data[0].FL_DATE); //this works\n\n      data.forEach(function(d) { \n        d.date = parseDate(d.FL_DATE);\n        d.carrier = d.MKT_UNIQUE_CARRIER;\n        d.delay = +d.NUM_OF_DELAY;  \n\n      });\n\n      \n      var sumstat = nest() // nest function allows to group the calculation per level of a factor\n          .key(function(d) { return d.carrier;})\n          .entries(data);\n\n      //console.log(sumstat); //working\n\n      var arr_time = d3.extent(data, function(d) { return d.date; })\n      \n      var margin = {top: 10, right: 30, bottom: 30, left: 60},\n          width = 1200 - margin.left - margin.right,\n          height = 600 - margin.top - margin.bottom;\n\n      // append the svg object to the body of the page\n      var svg = d3.select(\"#line_chart\")\n        .append(\"svg\")\n          .attr(\"width\", width + margin.left + margin.right)\n          .attr(\"height\", height + margin.top + margin.bottom)\n        .append(\"g\")\n          .attr(\"transform\",\n                \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n      //console.log(arr_time); //working\n      //Add x-axis\n      var x = d3.scaleLinear()\n        .domain(arr_time)\n        .range([ 0, width ]);\n      svg.append(\"g\")\n        .transition()\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(d3.axisBottom(x).ticks(32).tickFormat(d3.timeFormat('%b %d')));\n\n      var max_data = d3.max(data, function(d) { return +d.delay; })\n      //console.log(max_data)\n\n      // Add y-axis\n      var y = d3.scaleLinear()\n        .domain([0, max_data])\n        .range([ height, 0 ]);\n      svg.append(\"g\")\n        .call(d3.axisLeft(y))\n        .append('text')\n        .attr(\"x\", -150)\n        .attr(\"y\", -40)\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"fill\", \"#696969\")\n        .attr(\"font-size\", \"14px\")\n        .text(\"Number of Delayed Flights\");\n\n      var color = d3.scaleOrdinal(d3.schemeCategory10);\n\n      /*\n      const transitionPath = d3\n        .transition()\n        .ease(d3.easeSin)\n        .duration(1000);*/\n      //console.log(transitionPath)\n\n      svg.selectAll(\".line\")\n      .data(sumstat)\n      .enter()\n      .append(\"path\")\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", function(d){ return color(d.key) })\n        .attr(\"stroke-width\", lineStroke)\n        .attr(\"opacity\", lineOpacity)\n        .attr(\"d\", function(d){\n          return d3.line()\n            .x(function(d) { return x(d.date); })\n            .y(function(d) { return y(+d.delay); })(d.values)\n        })\n        .on(\"mouseover\", function(d,i) {\n          //console.log(i)\n            svg.append(\"text\")\n              .transition()\n              .ease(d3.easeSin)\n              .attr(\"class\", \"title-text\")\n              .style(\"fill\", color(i.key))  \n              .style(\"font-size\", \"22px\")      \n              .text(\"Carrier: \"+i.key)\n              .attr(\"text-anchor\", \"middle\")\n              .attr(\"x\", 100)\n              .attr(\"y\", 20);\n            d3.selectAll('.line')\n            .style('opacity', otherLinesOpacityHover);\n            d3.select(this)\n              .style('opacity', lineOpacityHover)\n              .style(\"stroke-width\", lineStrokeHover)\n              .style(\"cursor\", \"pointer\");\n          })\n        .on(\"mouseout\", function() {\n            svg.select(\".title-text\").remove();\n            d3.selectAll(\".line\")\n                .style('opacity', lineOpacity);\n            d3.select(this)\n              .style('opacity', lineOpacity)\n              .style(\"stroke-width\", lineStroke)\n              .style(\"cursor\", \"none\");\n          })\n          ;\n\n        \n      \n        var curtain = svg.append('rect')\n          .attr('x', -1 * width)\n          .attr('y', -1 * height)\n          .attr('height', height)\n          .attr('width', width)\n          .attr('class', 'curtain')\n          .attr('transform', 'rotate(180)')\n          .style('fill', '#ffffff');\n          \n        /* Optionally add a guideline */\n        var guideline = svg.append('line')\n          .attr('stroke', '#333')\n          .attr('stroke-width', 0)\n          .attr('class', 'guide')\n          .attr('x1', 1)\n          .attr('y1', 1)\n          .attr('x2', 1)\n          .attr('y2', height)\n          \n        /* Create a shared transition for anything we're animating */\n        var t = svg.transition()\n          .delay(750)\n          .duration(6000)\n          .ease(d3.easeLinear)\n          .on('end', function() {\n            d3.select('line.guide')\n              .transition()\n              .style('opacity', 0)\n              .remove()\n          });\n        \n        t.select('rect.curtain')\n          .attr('width', 0);\n        t.select('line.guide')\n          .attr('transform', 'translate(' + width + ', 0)')\n\n        d3.select(\"#show_guideline\").on(\"change\", function() {\n          guideline.attr('stroke-width', this.checked ? 1 : 0);\n          curtain.attr(\"opacity\", this.checked ? 0.75 : 1);\n        })                              \n    },\n    buildTreemap() {\n      var width = 954;\n      var height = 954;\n\n      const keys = d3.range(1, 32);\n      //console.log(keys)\n      //console.log(this.treemapData)\n\n      var data = this.treemapData;\n\n      data.forEach(function(d) { \n        d.name = d.ORIGIN_STATE_NM\n        d.values =  keys.map(key => +d[key].replace(/,/g, \"\"))\n      });\n      //console.log(data)\n      \n      const regionByState = new Map(this.region.map(d => [d.State, d.Region]));\n      //console.log(regionByState)\n      const divisionByState = new Map(this.region.map(d => [d.State, d.Division]));\n      //console.log(divisionByState)\n\n      const group = d3.group(data, d => regionByState.get(d.ORIGIN_STATE_NM), d => divisionByState.get(d.ORIGIN_STATE_NM))\n      //console.log(group)\n\n      var color = d3.scaleOrdinal(group.keys(), d3.schemeCategory10.map(d => d3.interpolateRgb(d, \"white\")(0.5)))\n      //console.log(color)\n\n      var sums = keys.map((d, i) => d3.hierarchy(group).sum(d => d.values[i]).value);\n      //console.log(sums)\n\n      var max = d3.max(sums);\n      //console.log(max)\n\n      const treemap = d3.treemap()\n      .tile(d3.treemapResquarify)\n      .size([width, height])\n      .padding(d => d.height === 1 ? 1 : 0)\n      .round(true);\n\n      //console.log(treemap)\n\n      const root = treemap(d3.hierarchy(group)\n        .sum(d => Array.isArray(d.values) ? d3.sum(d.values) : 0)\n        .sort((a, b) => b.value - a.value));\n      //console.log(root)\n    \n\n    var svg = d3.select(\"#treemap\")\n        .append(\"svg\")\n        .attr(\"font-family\", \"sans-serif\")\n        .attr(\"font-size\", 10)\n        .style(\"overflow\", \"visible\");\n\n    var formatNumber = d3.format(\",d\");\n    var duration = 2500;\n    var parseNumber = string => +string.replace(/,/g, \"\");\n\n    var box = svg.append(\"g\")\n    .selectAll(\"g\")\n    .data(keys.map((key, i) => {\n      const value = root.sum(d => d.values[i]).value;\n      return {key, value, i, k: Math.sqrt(value / max)};\n    }).reverse())\n    .join(\"g\")\n      .attr(\"transform\", ({k}) => `translate(${(1 - k) / 2 * width},${(1 - k) / 2 * height})`)\n      .call(g => g.append(\"text\")\n          .attr(\"y\", -6)\n          .attr(\"fill\", \"#777\")\n        .selectAll(\"tspan\")\n        .data(({key, value}) => [key, ` ${formatNumber(value)}`])\n        .join(\"tspan\")\n          .attr(\"font-weight\", (d, i) => i === 0 ? \"bold\" : null)\n          .text(d => d))\n      .call(g => g.append(\"rect\")\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"#ccc\")\n          .attr(\"width\", ({k}) => k * width )\n          .attr(\"height\", ({k}) => k * height));\n      \n      //console.log(box)\n\n       const leaf = svg.append(\"g\")\n          .selectAll(\"g\")\n          .data(layout(keys))\n          .join(\"g\")\n            .attr(\"transform\", d => `translate(${d.x0},${d.y0})`);\n        //console.log(leaf)\n        \n        leaf.append(\"rect\")\n            //.attr(\"id\", d => (d.leafUid = DOM.uid(\"leaf\")).id)\n            .attr(\"fill\", d => { while (d.depth > 1) d = d.parent; return color(keys); })\n            .attr(\"width\", d => d.x1 - d.x0)\n            .attr(\"height\", d => d.y1 - d.y0);\n        /*\n        leaf.append(\"clipPath\")\n            .attr(\"id\", d => (d.clipUid = DOM.uid(\"clip\")).id)\n          .append(\"use\")\n            .attr(\"xlink:href\", d => d.leafUid.href);\n        */\n        leaf.append(\"text\")\n            .attr(\"clip-path\", d => d.clipUid)\n          .selectAll(\"tspan\")\n          .data([group.name, formatNumber(group.value)])\n          .join(\"tspan\")\n            .attr(\"x\", 3)\n            .attr(\"y\", (d, i, nodes) => `${(i === nodes.length - 1) * 0.3 + 1.1 + i * 0.9}em`)\n            .attr(\"fill-opacity\", (d, i, nodes) => i === nodes.length - 1 ? 0.7 : null)\n            .text(d => d);\n\n        leaf.append(\"title\")\n            .text(group.name);\n\n        function layout(index) {\n          const k = Math.sqrt(root.sum(d => d.values[index]).value / max);\n          const x = (1 - k) / 2 * width;\n          const y = (1 - k) / 2 * height;\n          return treemap.size([width * k, height * k])(root)\n            .each(d => (d.x0 += x, d.x1 += x, d.y0 += y, d.y1 += y))\n            .leaves();\n        }\n\n  return Object.assign(svg.node(), {\n    update(index) {\n      box.transition()\n          .duration(duration)\n          .attr(\"opacity\", ({i}) => i >= index ? 1 : 0);\n\n      leaf.data(layout(index)).transition()\n          .duration(duration)\n          .ease(d3.easeLinear)\n          .attr(\"transform\", d => `translate(${d.x0},${d.y0})`)\n          .call(leaf => leaf.select(\"rect\")\n              .attr(\"width\", d => d.x1 - d.x0)\n              .attr(\"height\", d => d.y1 - d.y0))\n          .call(leaf => leaf.select(\"text tspan:last-child\")\n              .tween(\"text\", function(d) {\n                const i = d3.interpolate(parseNumber(this.textContent), d.value);\n                return function(t) { this.textContent = formatNumber(i(t)); };\n              }));\n    }\n  });\n\n    },\n    buildPieChart(){\n\n        var width = 600;\n        var height = 600;\n        var radius = Math.min(width, height) / 2;\n        var donutWidth = 120;\n        var legendRectSize = 15;\n        var legendSpacing = 5;\n\n        var color = d3.scaleOrdinal(d3.schemeCategory10);\n\n        var dataset = this.pieData;\n        \n        dataset.forEach(function(d) {\n            d.count = +d.count;\n          });\n\n        console.log(dataset);\n\n        var svg = d3.select('#pie_chart')\n          .append('svg')\n          .attr('width', width)\n          .attr('height', height)\n          .append('g')\n          .attr('transform', 'translate(' + (width / 2) + \n            ',' + (height / 2) + ')');\n\n        var arc = d3.arc()\n          .innerRadius(radius - donutWidth)\n          .outerRadius(radius);\n\n        var pie = d3.pie()\n          .value(function(d) { return d.count; })\n          .sort(null);\n                                 \n\n          var path = svg.selectAll('path')\n            .data(pie(dataset))\n            .enter()\n            .append('path')\n            .attr('d', arc)\n            .attr('fill', function(d) { \n              return color(d.data.label);\n            })\n            .on('mouseover', function(d,i) {                            \n            var total = d3.sum(dataset.map(function(d) {  \n              return d.count;                                           \n            }));                                                          \n            var percent = Math.round(1000 * i.data.count / total) / 10; \n\n            d3.select(this)\n            .attr(\"stroke\", \"#000\")\n\n            svg.append(\"text\")\n            .attr(\"y\", 100)\n            .style(\"text-anchor\", \"middle\")\n            .style(\"font-size\", 24)\n            .attr(\"class\",\"label\")\n            .style(\"fill\", color(i.data.label))\n            .text(\"Percentage:\" + percent + \"%\");\n\n            svg.append(\"text\")\n            .attr(\"y\", -90)\n            .style(\"text-anchor\", \"middle\")\n            .style(\"font-size\", 24)\n            .attr(\"class\",\"label2\")\n            .style(\"fill\", color(i.data.label))\n            .text(i.data.label);\n\n          });               \n          \n          path.on('mouseout', function() {                                \n            d3.select(this).attr(\"stroke\", null);  \n            svg.select(\".label\").remove();\n            svg.select(\".label2\").remove();                         \n          });                                                             \n\n        /*\n          path.on('mousemove', function(d) {  \n            tooltip.style('top', (d.pageY + 10) + 'px')          \n              .style('left', (d3.pageX + 10) + 'px');             \n          });      */                                                     \n            \n          var legend = svg.selectAll('.legend')\n            .data(color.domain())\n            .enter()\n            .append('g')\n            .attr('class', 'legend')\n            .attr('transform', function(d, i) {\n              var height = legendRectSize + legendSpacing;\n              var offset =  height * color.domain().length / 2;\n              var horz = -6 * legendRectSize;\n              var vert = i * height - offset;\n              return 'translate(' + horz + ',' + vert + ')';\n            });\n\n          legend.append('rect')\n            .attr('width', legendRectSize)\n            .attr('height', legendRectSize)                                   \n            .style('fill', color)\n            .style('stroke', color);\n            \n          legend.append('text')\n            .attr('x', legendRectSize + legendSpacing)\n            .attr('y', legendRectSize - legendSpacing)\n            .text(function(d) { return d; });\n    }\n\n  },\n  mounted: function () {\n\n    if (!this.$store.state.htmlMapData) {\n      var promises = []\n      promises.push(d3.csv('Data_for_line_chart.csv'))\n      promises.push(d3.csv('us-region.csv'))\n      promises.push(d3.csv('Data_for_treemap.csv'))\n      promises.push(d3.csv('delay.csv'))\n      Promise.all(promises).then(values => {\n        this.rawData = values\n        this.lineData = values[0]\n        this.region = values[1]\n        this.treemapData = values[2]\n        this.pieData = values[3]\n        this.$store.commit('htmlMapData', this.rawData);\n        //this.chart();\n        this.buildLineChart();\n        //this.buildTreemap();\n        this.buildPieChart();\n      })\n    } else {\n      this.rawData = this.$store.state.htmlMapData;\n      this.lineData = this.rawData[0]\n      this.region = this.rawData[1]\n      this.treemapData = this.rawData[2]\n      this.chart();\n      this.buildLineChart();\n      //this.buildTreemap();\n      this.buildPieChart();\n    }\n\n    }\n  }\n\n</script>\n\n<style>\n.title{\n  font-size: 24px;\n\n}\n\n</style>\n\n/*reference:\nOverall:\nhttps://observablehq.com/@hydrosquall/d3-tutorial-interactivity-animated-transitions\n\nLine Plot:\nhttps://www.d3-graph-gallery.com/graph/line_several_group.html\n\nMouseOver:\nhttp://bl.ocks.org/WilliamQLiu/76ae20060e19bf42d774\nhttps://codepen.io/zakariachowdhury/pen/JEmjwq\n\nAnimation:\nhttps://bl.ocks.org/phvaillant/53b90038b9c5ac5f6b817a4f63fbc2af\nhttp://bl.ocks.org/atmccann/8966400\n\n*/"]}]}